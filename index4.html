<!DOCTYPE html>
<html>
 <head>
	<link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre.min.css">
	<link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-exp.min.css">
	<link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-icons.min.css">
	<meta charset="utf-8">
	<title>Системы контроля версий</title>
 </head>
 
 <body>
	<div style="height: 100%; width: 200px; position: fixed; top: 50px; left: 0;">
		<ul class="menu">
			<li class="menu-item">
				<a href="index.html">Системы контроля версий</a>
			</li>
			<li class="menu-item">
				<a href="index2.html">Общие сведения</a>
			</li>
			<li class="menu-item">
				<a href="index3.html">Типы систем</a>
			</li>
			<li class="menu-item">
				<a href="index4.html">Порядок работы с системами</a>
			</li>
			<li class="menu-item">
				<a href="index5.html">Git</a>
			</li>
			<li class="menu-item">
				<a href="index6.html">Subversion (SVN)</a>
			</li>
			<li class="menu-item">
				<a href="index7.html">Mercurial</a>
			</li>
		</ul>
	
	</div>
	<div style="margin-left: 200px; top: 0; border: 0px solid #a7d7f9;">
	<header class="navbar">
	<section class="navbar-section">
	<a>Страницы:&nbsp</a>
	<a href="index.html">1</a>
	<a>,&nbsp</a>
	<a href="index2.html">2</a>
	<a>,&nbsp</a>
	<a href="index3.html">3</a>
	<a>,&nbsp</a>
	<a href="index4.html">4</a>
	<a>,&nbsp</a>
	<a href="index5.html">5</a>
	<a>,&nbsp</a>
	<a href="index6.html">6</a>
	<a>,&nbsp</a>
	<a href="index7.html">7</a>
	</section>
	<section class="navbar-center">
    <span class="h1">Mercurial</span>
	</section>
	<section class="navbar-center">
    <span class="h1">Порядок работы с системами</span>
	</section>
	<section class="navbar-section">
	<a  href="index.html"><img src="g.png" width=50pt height=50pt alt="..."></a>
  </section>
</header>
	<div style="padding-left: 5px; padding-right: 80px; text-align: justify; font-size:20px; padding-top: 10px;text-indent: 30px;">
		<p>Каждая система управления версиями имеет свои специфические особенности в наборе команд, порядке работы пользователей и администрировании. 
		Тем не менее, общий порядок работы для большинства VCS совершенно стереотипен. 
		Здесь предполагается, что проект, каким бы он ни был, уже существует и на сервере размещён его репозиторий, к которому разработчик получает доступ.</p>
		<div class="divider"></div>
		<h5>Начало работы с проектом</h5>
		<p>Первым действием, которое должен выполнить разработчик, является извлечение рабочей копии проекта или той его части, с которой предстоит работать. 
		Это действие выполняется с помощью команды извлечения версии (обычно checkout или clone). Разработчик задаёт версию, 
		которая должна быть скопирована, по умолчанию обычно копируется последняя (или выбранная администратором в качестве основной) версия.</p>
		<p>По команде извлечения устанавливается соединение с сервером, и проект (или его часть — один из каталогов с подкаталогами)
		в виде дерева каталогов и файлов копируется на компьютер разработчика. Обычной практикой является дублирование рабочей копии: 
		помимо основного каталога с проектом на локальный диск (либо в отдельный, специально выбранный каталог, либо в системные подкаталоги 
		основного дерева проекта) дополнительно записывается ещё одна его копия. Работая с проектом, разработчик изменяет только файлы 
		основной рабочей копии. Вторая локальная копия хранится в качестве эталона, позволяя в любой момент без обращения к серверу определить, 
		какие изменения внесены в конкретный файл или проект в целом и от какой версии была «отпочкована» рабочая копия; как правило, 
		любая попытка ручного изменения этой копии приводит к ошибкам в работе программного обеспечения VCS.</p>
		<div class="divider"></div>
		<h5>Ежедневный цикл работы</h5>
		<p>При некоторых вариациях, определяемых особенностями системы и деталями принятого технологического процесса, 
		обычный цикл работы разработчика в течение рабочего дня выглядит следующим образом.</p>
		<h5>1. Обновление рабочей копии</h5>
		<p>По мере внесения изменений в основную версию проекта рабочая копия на компьютере разработчика стареет: расхождение её с 
		основной версией проекта увеличивается. Это повышает риск возникновения конфликтных изменений (см. ниже). 
		Поэтому удобно поддерживать рабочую копию в состоянии, максимально близком к текущей основной версии, для чего разработчик 
		выполняет операцию обновления рабочей копии (update) насколько возможно часто (реальная частота обновлений определяется частотой 
		внесения изменений, зависящей от активности разработки и числа разработчиков, а также временем, затрачиваемым на каждое обновление
		— если оно велико, разработчик вынужден ограничивать частоту обновлений, чтобы не терять время).</p>
		<h5>2. Модификация проекта</h5>
		<p>Разработчик модифицирует проект, изменяя входящие в него файлы в рабочей копии в соответствии с проектным заданием. 
		Эта работа производится локально и не требует обращений к серверу VCS.</p>
		<h5>3. Фиксация изменений</h5>
		<p>Завершив очередной этап работы над заданием, разработчик фиксирует (commit) свои изменения, 
		передавая их на сервер (либо в основную ветвь, если работа над заданием полностью завершена, либо в отдельную 
		ветвь разработки данного задания). VCS может требовать от разработчика перед фиксацией обязательно выполнить 
		обновление рабочей копии. При наличии в системе поддержки отложенных изменений (shelving) изменения могут быть переданы на сервер без фиксации. 
		Если утверждённая политика работы в VCS это позволяет, то фиксация изменений может проводиться не ежедневно, а только по 
		завершении работы над заданием; в этом случае до завершения работы все связанные с заданием изменения сохраняются только в 
		локальной рабочей копии разработчика.</p>
		<div class="divider"></div>
		<h5>Ветвления</h5>
		<p>Делать мелкие исправления в проекте можно путём непосредственной правки рабочей копии и последующей 
		фиксации изменений прямо в главной ветви (в стволе) на сервере. Однако при выполнении объёмных работ такой 
		порядок становится неудобным: отсутствие фиксации промежуточных изменений на сервере не позволяет работать 
		над чем-либо в групповом режиме, кроме того, повышается риск потери изменений при локальных авариях и теряется 
		возможность анализа и возврата к предыдущим вариантам кода в пределах данной работы. Поэтому для таких изменений 
		обычной практикой является создание ветвей (branch), то есть «отпочковывание» от ствола в какой-то версии нового 
		варианта проекта или его части, разработка в котором ведётся параллельно с изменениями в основной версии. 
		Ветвь создаётся специальной командой. Рабочая копия ветви может быть создана заново обычным образом (командой 
		извлечения рабочей копии, с указанием адреса или идентификатора ветви), либо путём переключения имеющейся рабочей копии на заданную ветвь.</p>
		<p>Базовый рабочий цикл при использовании ветвей остаётся точно таким же, как и в общем случае: 
		разработчик периодически обновляет рабочую копию (если с ветвью работает более одного человека)
		и фиксирует в ней свою ежедневную работу. Иногда ветвь разработки так и остаётся самостоятельной 
		(когда изменения порождают новый вариант проекта, который далее развивается отдельно от основного), 
		но чаще всего, когда работа, для которой создана ветвь, выполнена, ветвь реинтегрируется в ствол (основную ветвь). 
		Это может делаться командой слияния (обычно merge), либо путём создания патча (patch), содержащего внесённые 
		в ходе разработки ветви изменения и применения этого патча к текущей основной версии проекта.</p>
		<div class="divider"></div>
		<h5>Слияние версий</h5>
		<ul>Три вида операций, выполняемых в системе управления версиями, могут приводить к необходимости объединения изменений. Это:
			<li>Обновление рабочей копии (изменения, сделанные в основной версии, сливаются с локальными).</li>
			<li>Фиксация изменений (локальные изменения сливаются с изменениями, уже зафиксированными в основной версии).</li>
			<li>Слияние ветвей (изменения, сделанные в одной ветви разработки, сливаются с изменениями, сделанными в другой).</li>
		</ul>
		<ul>Во всех случаях ситуация принципиально одинакова и имеет следующие характерные черты:
			<li>Ранее была сделана копия дерева файлов и каталогов репозитория или его части.</li>
			<li>Впоследствии и в оригинальное дерево, и в копию были независимо внесены некоторые изменения.</li>
			<li>Требуется объединить изменения в оригинале и копии таким образом, чтобы не нарушить логическую связность проекта и не потерять данные.</li>
		</ul>
		<ul>Совершенно очевидно, что при невыполнении второго условия (то есть если изменения были внесены только в оригинал или только в копию) 
		объединение элементарно — достаточно скопировать изменённую часть туда, где изменений не было. 
		В противном случае слияние изменений превращается в нетривиальную задачу, во многих случаях требующую вмешательства разработчика. 
		В целом механизм автоматического слияния изменений работает, основываясь на следующих принципах:
			<li>Изменения могут состоять в модификации содержимого файла, создании нового файла или каталога, 
			удалении или переименовании ранее существовавшего файла или каталога в проекте.</li>
			<li>Если два изменения относятся к разным и не связанным между собой файлам и/или каталогам, они всегда могут быть объединены автоматически. 
			Их объединение состоит в том, что изменения, сделанные в каждой версии проекта, копируются в объединяемую версию.</li>
			<li><ul>Создание, удаление и переименование файлов в каталогах проекта могут быть объединены автоматически, если только они не конфликтуют между собой. В этом случае изменения, сделанные в каждой версии проекта, копируются в объединяемую версию. Конфликтующими обычно являются:
				<li>Удаление и изменение одного и того же файла или каталога.</li>
				<li>Удаление и переименование одного и того же файла или каталога (в случае, если система поддерживает операцию переименования).</li>
				<li>Создание в разных версиях файла с одним и тем же именем и разным содержимым.</li>
			</ul></li>
			<li>Изменения в пределах одного текстового файла, сделанные в разных версиях, могут быть объединены, 
			если они находятся в разных местах этого файла и не пересекаются. В этом случае в объединённую версию вносятся все сделанные изменения.</li>
			<li>Изменения в пределах одного файла, если он не является текстовым, всегда являются конфликтующими и не могут быть объединены автоматически.</li>
		</ul>
		<p>Во всех случаях базовой версией для слияния является версия, в которой было произведено разделение сливаемых версий. 
		Если это операция фиксации изменений, то базовой версией будет версия последнего обновления перед фиксацией, 
		если обновление — то версия предыдущего обновления, если слияние ветвей — то версия, в которой была создана соответствующая ветвь. 
		Соответственно, сопоставляемыми наборами изменений будут наборы изменений, сделанных от базовой до текущей версии во всех объединяемых вариантах.</p>
		<p>Абсолютное большинство современных систем управления версиями ориентировано, в первую очередь, 
		на проекты разработки программного обеспечения, в которых основным видом содержимого файла является текст. 
		Соответственно, механизмы автоматического слияния изменений ориентируются на обработку текстовых файлов, 
		то есть файлов, содержащих текст, состоящий из строк буквенно-цифровых символов, пробелов и табуляций, разделённых символами перевода строки.</p>
		<p>При определении допустимости слияния изменений в пределах одного и того же текстового файла работает типовой механизм построчного сравнения 
		текстов (примером его реализации является системная утилита GNU diff), который сравнивает объединяемые версии с базовой и 
		строит список изменений, то есть добавленных, удалённых и заменённых наборов строк. Минимальной единицей данных для этого алгоритма 
		является строка, даже самое малое отличие делает строки различными. С учётом того, что символы-разделители, в большинстве случаев, 
		не несут смысловой нагрузки, механизм слияния может игнорировать эти символы при сравнении строк.</p>
		<p>Те найденные наборы изменённых строк, которые не пересекаются между собой, считаются совместимыми и их слияние делается автоматически. 
		Если в сливаемых файлах находятся изменения, затрагивающие одну и ту же строку файла, это приводит к конфликту. Такие файлы могут быть 
		объединены только вручную. Любые файлы, кроме текстовых, с точки зрения VCS являются бинарными и не допускают автоматического слияния.</p>
		<div class="divider"></div>
		<h5>Конфликты и их разрешение</h5>
		<p>Ситуацию, когда при слиянии нескольких версий сделанные в них изменения пересекаются между собой, называют конфликтом. 
		При конфликте изменений система управления версиями не может автоматически создать объединённый проект и вынуждена обращаться 
		к разработчику. Как уже говорилось выше, конфликты могут возникать на этапах фиксации изменений, обновления или слияния ветвей.
		Во всех случаях при обнаружении конфликта соответствующая операция прекращается до его разрешения.</p>
		<p>Для разрешения конфликта система, 
		в общем случае, предлагает разработчику три варианта конфликтующих файлов: базовый, локальный и серверный. 
		Конфликтующие изменения либо показываются разработчику в специальном программном модуле объединения изменений 
		(в этом случае там демонстрируются сливаемые варианты и динамически изменяющийся в зависимости от команд пользователя 
		объединённый вариант файла), либо просто помечаются специальной разметкой прямо в тексте объединённого файла 
		(тогда разработчик должен сам сформировать желаемый текст в спорных местах и сохранить его).</p>
		<p>Конфликты в файловой системе разрешаются проще: там может конфликтовать только удаление файла с одной 
		из прочих операций, а порядок файлов в каталоге не имеет значения, так что разработчику остаётся лишь выбрать,
		какую операцию нужно сохранить в сливаемой версии.</p>
		<div class="divider"></div>
		<h5>Блокировки</h5>
		<ul>Механизм блокировки позволяет одному из разработчиков захватить в монопольное использование файл или группу файлов для внесения в них изменений. 
		На то время, пока файл заблокирован, он остаётся доступным всем остальным разработчикам только на чтение, и любая попытка внести 
		в него изменения отвергается сервером. Технически блокировка может быть организована по-разному. Типичным для современных систем 
		является следующий механизм.
			<li>Файлы, для работы с которыми требуется блокировка, помечаются специальным флагом «блокируемый». 
			Такая пометка может ставиться автоматически при добавлении файла в проект, обычно для этого предварительно создаётся 
			список масок имён файлов, которые при добавлении должны становиться блокируемыми.</li>
			<li>Если файл помечен как блокируемый, то при извлечении рабочей копии с сервера 
			он получает в локальной файловой системе атрибут «только для чтения», что препятствует его случайному редактированию.</li>
			<li><ul>Разработчик, желающий изменить файл, вызывает специальную команду блокировки (lock) с указанием имени этого файла. 
			В результате работы этой команды происходит следующее:
				<li>Cервер проверяет, не заблокирован ли уже файл другим разработчиком; если это так, то команда блокировки завершается с 
				ошибкой «файл заблокирован другим пользователем» и разработчик, вызывавший её, должен ожидать, 
				пока другой пользователь не снимет свою блокировку;</li>
				<li>Файл на сервере помечается как «заблокированный», с сохранением идентификатора заблокировавшего его разработчика и времени блокировки;</li>
				<li>Если блокировка на сервере прошла удачно, на локальной файловой системе 
				с файла рабочей копии снимается атрибут «только для чтения», что позволяет начать его редактировать.</li>
			</ul>
			<li>Разработчик работает с заблокированным файлом. Если в процессе работы выясняется, что файл изменять не нужно, 
			он может вызвать команду снятия блокировки (unlock, release lock). Все изменения файла будут отменены, 
			локальный файл вернётся в состояние «только для чтения», с файла на сервере будет снят атрибут «заблокирован» и 
			другие разработчики получат возможность изменять этот файл.</li>
			</li>По завершении работы с блокируемым файлом разработчик фиксирует изменения. Обычно блокировка при этом снимается автоматически, хотя в некоторых системах блокировку
			требуется снимать вручную после фиксации, либо указывать в команде фиксации изменений соответствующий параметр. Так или иначе, при этом 
			файл после изменений теряет флаг «заблокирован» и может быть изменён другими разработчиками.</li>
		</ul>
		<ul>Массовое использование блокировок, когда все или большинство файлов в проекте являются блокируемыми и 
		для любых изменений необходимо заблокировать соответствующий набор файлов, называется ещё стратегией 
		«блокированного извлечения». Ранние системы управления версиями поддерживали исключительно эту стратегию
		, предотвращая таким способом появление конфликтов на корню. В современных VCS предпочтительным является использование 
		неблокирующих извлечений, блокировки же считаются скорее неизбежным злом, которое нужно по возможности ограничивать. 
		Недостатки использования блокировок очевидны:
			<li>Блокировки просто мешают продуктивной работе, поскольку вынуждают ожидать освобождения блокированных файлов,
			хотя в большинстве случаев даже совместные изменения одних и тех же файлов, которые делаются в ходе разных по смыслу работ,
			не пересекаются и объединяются при слиянии автоматически.</li>
			<li>Частота возникновения конфликтов и сложность их разрешения в большинстве случаев не настолько велики, 
			чтобы создать серьёзные затруднения. Возникновение же серьёзного конфликта изменений чаще всего сигнализирует 
			либо о существенном расхождении во мнениях разных разработчиков относительно дизайна одного и того же фрагмента, 
			либо о неправильной организации работы (когда два или более разработчиков делают одно и то же).</li>
			<li>Блокировки создают административные проблемы. Типичный пример: разработчик может забыть снять блокировку 
			с занятых им файлов, уходя в отпуск. Для разрешения подобных проблем приходится применять административные меры, 
			в том числе включать в систему технические средства для сброса неверных блокировок, но и при их наличии на приведение 
			системы в порядок расходуется время.</li>
		</ul>
		<p>С другой стороны, в некоторых случаях использование блокировок вполне оправданно. 
		Очевидным примером является организация работы с бинарными файлами, для которых нет инструментальных 
		средств слияния изменений либо такое слияние принципиально невозможно (как, например, для файлов изображений). 
		Если автоматическое слияние невозможно, то при обычном порядке работы любое параллельное изменение подобных 
		файлов будет приводить к конфликту. В данном случае гораздо удобнее сделать такой файл блокируемым, чтобы гарантировать, 
		что любые изменения в него будут вноситься только последовательно.</p>
		<div class="divider"></div>
		<h5>Версии проекта, теги</h5>
		<p>Система управления версиями обеспечивает хранение всех существовавших вариантов файлов и, как следствие, всех вариантов проекта в целом,
		имевших место с момента начала его разработки. Но само понятие «версии» в разных системах может трактоваться двояко.</p>
		<p>Одни системы поддерживают версионность файлов. Это означает, что любой файл, появляющийся в проекте, 
		получает собственный номер версии (обычно — номер 1, условной «нулевой» версией файла считается пустой файл с тем же именем). 
		При каждой фиксации разработчиком изменений, затрагивающих файл, соответствующая часть фиксируемых изменений применяется к 
		файлу и файл получает новый, обычно следующий по порядку, номер версии. Поскольку фиксации обычно затрагивают только часть 
		файлов в репозитории, номера версий файлов, имеющиеся на один и тот же момент времени, со временем расходятся, и проект 
		в целом (то есть весь набор файлов репозитория), фактически, никакого «номера версии» не имеет, поскольку состоит из 
		множества файлов с различными номерами версий. Подобным образом работает, например, система управления версиями CVS.</p>
		<p>Для других систем понятие «версия» относится не к отдельному файлу, а к репозиторию целиком. 
		Вновь созданный пустой репозиторий имеет версию 1 или 0, любая фиксация изменений приводит к увеличению этого номера 
		(то есть даже при изменении одного файла на один байт весь репозиторий считается изменённым и получает новый номер версии). 
		Таким способом трактует номера версий, например, система Subversion. Номера версии отдельного файла здесь, фактически, 
		не существует, условно можно считать таковым текущий номер версии репозитория (то есть считать, что при каждом изменении, 
		внесённом в репозиторий, все его файлы меняют номер версии, даже те, которые не менялись). Иногда, говоря о «версии файла» 
		в таких системах, имеют в виду ту версию репозитория, в которой файл был последний раз (до интересующего нас момента) изменён.</p>
		<p>Для практических целей обычно имеет значение не отдельный файл, а весь проект целиком. 
		В системах, поддерживающих версионность отдельных файлов, для идентификации определённой версии проекта можно 
		использовать дату и время — тогда версия проекта будет состоять из тех версий входящих в него файлов, которые имелись 
		в репозитории на указанный момент времени. Если поддерживается версионность репозитория в целом, номером версии 
		проекта может выступать номер версии репозитория. Однако оба варианта не слишком удобны, так как ни дата, 
		ни номер версии репозитория обычно не несут информации о значимых изменениях в проекте, о том, насколько долго 
		и интенсивно над ним работали. Для более удобной пометки версий проекта (или его частей) системы управления версиями поддерживают понятие тегов.</p>
		<p>Тег (tag) — это символическая метка, которая может быть связана с определённой версией файла и/или 
		каталога в репозитории. С помощью соответствующей команды всем или части файлов проекта, отвечающим определённым условиям 
		(например, входящим в головную версию главной ветви проекта на определённый момент времени) может быть присвоена заданная метка. 
		Таким образом можно идентифицировать версию проекта (версия «XX.XXX.XXX» — это набор версий файлов репозитория, 
		имеющих тег «XX.XXX.XXX»), зафиксировав таким образом его состояние на некоторый желаемый момент. Как правило, система тегов достаточно 
		гибкая и позволяет пометить одним тегом и не одновременные версии файлов и каталогов. Это позволяет собрать «версию проекта» 
		любым произвольным образом. С точки зрения пользователя системы пометка тегами может выглядеть по-разному. В некоторых системах 
		она изображается именно как пометка (тег можно создать, применить к определённым версиям файлов и каталогов, снять). В других 
		системах (например, Subversion) тег представляет собой просто отдельный каталог на файловом дереве репозитория, куда из ствола 
		и ветвей проекта с помощью команды копирования делаются копии нужных версий файлов. Так что визуально тег — это просто вынесенная 
		в отдельный каталог копия определённых версий файлов репозитория. По соглашению в дерево каталогов, соответствующее тегу, запрещена 
		фиксация изменений (то есть версия проекта, представляемая тегом, является неизменной).</p>
		<div class="divider"></div>
		<h5>Базовые принципы разработки ПО в VCS</h5>
		<ul>Порядок использования системы управления версиями в каждом конкретном случае определяется 
		техническими регламентами и правилами, принятыми в конкретной фирме или организации, разрабатывающей проект.
		Тем не менее, общие принципы правильного использования VCS немногочисленны и едины для любых разработок и систем управления версиями.
			<li>Любые рабочие, тестовые или демонстрационные версии проекта собираются только из репозитория системы. 
			«Персональные» сборки, включающие ещё незафиксированные изменения, могут делать только разработчики для
			целей промежуточного тестирования. Таким образом, гарантируется, что репозиторий содержит всё необходимое для создания рабочей версии проекта.</li>
			<li>Текущая версия главной ветви всегда корректна. Не допускается фиксация в 
			главной ветви неполных или не прошедших хотя бы предварительное тестирование изменений. 
			В любой момент сборка проекта, проведённая из текущей версии, должна быть успешной.</li>
			<li>Любое значимое изменение должно оформляться как отдельная ветвь. 
			Промежуточные результаты работы разработчика фиксируются в эту ветвь. После завершения работы над изменением 
			ветвь объединяется со стволом. Исключения допускаются только для мелких изменений, работа над которыми ведётся 
			одним разработчиком в течение не более чем одного рабочего дня.</li>
			<li>Версии проекта помечаются тегами. Выделенная и помеченная тегом версия более никогда не изменяется.</li>
		</ul>
	</div>
	</div>
	<footer style="position: fixed; right: 0; bottom: 0; text-align: right; width: 100%;">
	<b>Сайт подготовлен: Герко Михаил Юрьевич</b>
	</footer>
 </body>
 
</html>